-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.exercise
(
    id serial NOT NULL,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT exercise_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.girya
(
    id serial NOT NULL,
    weight integer NOT NULL,
    condition character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT girya_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.training
(
    id serial NOT NULL,
    user_id integer NOT NULL,
    training_date date NOT NULL,
    CONSTRAINT training_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.training_exercise
(
    id serial NOT NULL,
    training_id integer NOT NULL,
    exercise_id integer NOT NULL,
    girya_id integer NOT NULL,
    sets integer NOT NULL,
    reps integer NOT NULL,
    CONSTRAINT training_exercise_pkey PRIMARY KEY (id),
    CONSTRAINT training_exercise_training_id_exercise_id_girya_id_key UNIQUE (training_id, exercise_id, girya_id)
);

CREATE TABLE IF NOT EXISTS public.user_t
(
    id serial NOT NULL,
    first_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    date_of_birth date NOT NULL,
    CONSTRAINT user_t_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS public.training
    ADD CONSTRAINT training_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.user_t (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.training_exercise
    ADD CONSTRAINT training_exercise_exercise_fkey FOREIGN KEY (exercise_id)
    REFERENCES public.exercise (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE RESTRICT;
CREATE INDEX IF NOT EXISTS idx_training_exercise_exercise
    ON public.training_exercise(exercise_id);


ALTER TABLE IF EXISTS public.training_exercise
    ADD CONSTRAINT training_exercise_girya_fkey FOREIGN KEY (girya_id)
    REFERENCES public.girya (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE RESTRICT;


ALTER TABLE IF EXISTS public.training_exercise
    ADD CONSTRAINT training_exercise_training_fkey FOREIGN KEY (training_id)
    REFERENCES public.training (id) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE RESTRICT;
CREATE INDEX IF NOT EXISTS idx_training_exercise_training
    ON public.training_exercise(training_id);

	
CREATE OR REPLACE FUNCTION public.check_girya_weight()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    IF NEW.weight < 4 OR NEW.weight > 100 THEN
        RAISE EXCEPTION 'Вес гири должен быть от 4 кг до 100 кг';
    END IF;
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.check_girya_weight()
    OWNER TO fedos;

CREATE OR REPLACE VIEW public.exercise_weight_progress_view
 AS
 SELECT u.id AS user_id,
    (u.first_name::text || ' '::text) || u.last_name::text AS user_name,
    e.id AS exercise_id,
    e.name AS exercise_name,
    g.weight,
    min(t.training_date) AS first_used_date,
    max(t.training_date) AS last_used_date,
    count(te.id) AS times_performed,
    max(te.sets * te.reps) AS max_volume
   FROM user_t u
     JOIN training t ON u.id = t.user_id
     JOIN training_exercise te ON t.id = te.training_id
     JOIN exercise e ON te.exercise_id = e.id
     JOIN girya g ON te.girya_id = g.id
  GROUP BY u.id, u.first_name, u.last_name, e.id, e.name, g.weight;

ALTER TABLE public.exercise_weight_progress_view
    OWNER TO fedos;


CREATE OR REPLACE VIEW public.girya_usage_view
 AS
 SELECT g.weight,
    g.condition,
    count(te.id) AS times_used,
    string_agg(DISTINCT e.name::text, ', '::text) AS exercises_with_this_girya
   FROM girya g
     LEFT JOIN training_exercise te ON g.id = te.girya_id
     LEFT JOIN exercise e ON te.exercise_id = e.id
  GROUP BY g.id, g.weight, g.condition
  ORDER BY (count(te.id)) DESC;

ALTER TABLE public.girya_usage_view
    OWNER TO fedos;


CREATE OR REPLACE VIEW public.top_exercises_view
 AS
 SELECT e.name AS exercise_name,
    count(te.id) AS usage_count,
    count(DISTINCT t.user_id) AS unique_users_count,
    round(count(te.id)::numeric * 100.0 / (( SELECT count(*) AS count
           FROM training_exercise))::numeric, 2) AS percentage_of_total
   FROM exercise e
     JOIN training_exercise te ON e.id = te.exercise_id
     JOIN training t ON te.training_id = t.id
  GROUP BY e.name
  ORDER BY (count(te.id)) DESC
 LIMIT 3;

ALTER TABLE public.top_exercises_view
    OWNER TO fedos;


CREATE OR REPLACE VIEW public.training_details_view
 AS
 SELECT t.id AS training_id,
    (u.first_name::text || ' '::text) || u.last_name::text AS user_name,
    t.training_date,
    e.name AS exercise_name,
    g.weight AS girya_weight,
    te.sets,
    te.reps
   FROM training t
     JOIN user_t u ON t.user_id = u.id
     JOIN training_exercise te ON t.id = te.training_id
     JOIN exercise e ON te.exercise_id = e.id
     JOIN girya g ON te.girya_id = g.id;

ALTER TABLE public.training_details_view
    OWNER TO fedos;


CREATE OR REPLACE VIEW public.user_trainings_view
 AS
 SELECT t.id AS training_id,
    (u.first_name::text || ' '::text) || u.last_name::text AS user_name,
    t.training_date,
    count(te.id) AS exercises_count
   FROM training t
     JOIN user_t u ON t.user_id = u.id
     LEFT JOIN training_exercise te ON t.id = te.training_id
  GROUP BY t.id, u.first_name, u.last_name;

ALTER TABLE public.user_trainings_view
    OWNER TO fedos;
END;